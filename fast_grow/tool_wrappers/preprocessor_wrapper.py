"""A django model friendly wrapper around the preprocessor binary"""
import json
import os
from pathlib import Path
import subprocess
from tempfile import TemporaryDirectory
from django.conf import settings
from fast_grow.models import Ligand, SearchPointData


class PreprocessorWrapper:
    """A django model friendly wrapper around the preprocessor binary"""

    @staticmethod
    def preprocess(cmplx):
        """Preprocess a complex using the preprocessor binary

        :param cmplx django complex model to be preprocessed
        """
        directory = PreprocessorWrapper.execute_preprocessing(cmplx)
        result_path = Path(directory.name)
        PreprocessorWrapper.load_results(result_path, cmplx)

    @staticmethod
    def execute_preprocessing(cmplx):
        """Execute the preprocessor binary on the complex in the model

        If a ligand was explicitly specified it is considered in the commandline call.
        """
        complex_file = cmplx.write_temp()
        ligand_file = None
        if cmplx.ligand_set.count() > 1:  # pylint: disable=no-else-raise
            error_string = 'complex({}) to be processed has more than one ligand'.format(cmplx.id)
            raise RuntimeError(error_string)
        elif cmplx.ligand_set.count() == 1:
            ligand_file = cmplx.ligand_set.first().write_temp()
        # implicit zero case leaves ligand file at None
        directory = TemporaryDirectory()
        args = [
            os.path.join(settings.BASE_DIR, 'bin', 'preprocessor'),
            '--pocket', complex_file.name,
            '--outdir', directory.name,
        ]
        if ligand_file:
            args.extend(['--ligand', ligand_file.name])
        subprocess.check_call(args)
        return directory

    @staticmethod
    def load_results(path, cmplx):
        """Load all results into the database"""
        PreprocessorWrapper.load_clean_complex(path, cmplx)
        if cmplx.ligand_set.count() == 1:
            ligands = [cmplx.ligand_set.first()]
        else:
            ligands = PreprocessorWrapper.load_ligands(path, cmplx)

        for ligand in ligands:
            search_point_path = path.joinpath(ligand.name + '_search_points.json')
            if search_point_path.exists():
                PreprocessorWrapper.load_search_points(search_point_path, cmplx, ligand)

    @staticmethod
    def load_clean_complex(path, cmplx):
        """Load the new complex file generated by the preprocessor binary"""
        pdb_files = list(path.glob('*.pdb'))
        if len(pdb_files) > 1:
            raise RuntimeError('found more than one pdb file in output')
        with pdb_files[0].open() as pdb_file:
            clean_complex_string = pdb_file.read()
        cmplx.file_string = clean_complex_string
        cmplx.save()

    @staticmethod
    def load_ligands(path, cmplx):
        """Load all ligands extracted by the preprocessor binary

        :return ligands ligand models for the extracted ligands
        """
        ligands = []
        sd_files = list(path.glob('*.sdf'))
        for sd_file in sd_files:
            with sd_file.open() as ligand_file:
                ligand_string = ligand_file.read()
            ligand = Ligand(
                name=sd_file.stem, file_type='sdf', file_string=ligand_string, complex=cmplx)
            ligand.save()
            ligands.append(ligand)
        return ligands

    @staticmethod
    def load_search_points(path, cmplx, ligand):
        """Load search points generated for the ligand and the complex"""
        with open(path) as search_points_file:
            data = json.load(search_points_file)

        search_point_data = SearchPointData(
            data=json.dumps(data),
            complex=cmplx,
            ligand=ligand,
        )
        search_point_data.save()
